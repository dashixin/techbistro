<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>技术小馆 · 3D知识星球</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      background: #23243a;
      overflow: hidden;
    }

    #container {
      width: 100%;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
    }

    .tooltip {
      position: fixed;
      background: rgba(30, 30, 60, 0.95);
      color: #fff;
      padding: 10px 18px;
      border-radius: 8px;
      font-size: 1em;
      pointer-events: none;
      z-index: 99;
      display: none;
      max-width: 320px;
      left: 0;
      top: 0;
    }

    .reset-btn {
      position: fixed;
      right: 20px;
      top: 20px;
      z-index: 100;
      background: #1976d2;
      color: #fff;
      border: none;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 0.9em;
      cursor: pointer;
      opacity: 0.85;
    }

    .reset-btn:hover {
      opacity: 1;
    }

    /* 热门文章按钮样式 */
    .article-btn {
      position: fixed;
      right: 20px;
      top: 65px;
      z-index: 100;
      background: #ff7043;
      color: #fff;
      border: none;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 0.9em;
      cursor: pointer;
      opacity: 0.85;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    .article-btn:hover {
      opacity: 1;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    /* 加载指示器样式 */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #23243a;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 1.2em;
      z-index: 1000;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 255, 255, 0.2);
      border-top-color: #1976d2;
      border-radius: 50%;
      margin-bottom: 15px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* 触摸指引样式 */
    .touch-instructions {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9em;
      padding: 10px;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    /* 信息面板动画 */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #category-info {
      animation: fadeIn 0.3s ease-out;
    }

    /* 响应式布局 - 更完善的断点设计 */
    @media (max-width: 768px) {
      .tooltip {
        font-size: 0.9em;
        padding: 8px 14px;
        max-width: 260px;
      }

      .reset-btn {
        right: 15px;
        top: 15px;
        padding: 6px 12px;
        font-size: 0.8em;
      }

      .article-btn {
        right: 15px;
        top: 55px;
        padding: 6px 12px;
        font-size: 0.8em;
        max-width: 120px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .loading-spinner {
        width: 40px;
        height: 40px;
        border-width: 4px;
      }

      .touch-instructions {
        opacity: 1;
        font-size: 0.8em;
        bottom: 15px;
      }

      #category-info {
        left: 50% !important;
        transform: translateX(-50%);
        max-width: 85% !important;
        font-size: 0.9em;
        top: 60px;
      }
    }

    /* 小屏幕手机适配 */
    @media (max-width: 480px) {
      .reset-btn {
        right: 10px;
        top: 10px;
        padding: 5px 10px;
        font-size: 0.75em;
      }

      .article-btn {
        right: 10px;
        top: 45px;
        padding: 5px 10px;
        font-size: 0.75em;
        max-width: 100px;
      }

      .touch-instructions {
        font-size: 0.7em;
        bottom: 10px;
      }
    }

    /* 平板设备横屏适配 */
    @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
      .reset-btn {
        right: 25px;
        top: 25px;
      }

      .article-btn {
        right: 25px;
        top: 75px;
      }
    }

    /* 高分辨率设备适配 */
    @media (min-width: 1600px) {

      .reset-btn,
      .article-btn {
        padding: 10px 20px;
        font-size: 1.1em;
      }

      .reset-btn {
        right: 30px;
        top: 30px;
      }

      .article-btn {
        right: 30px;
        top: 85px;
      }

      .touch-instructions {
        font-size: 1em;
      }
    }

    .view-more-btn {
      background: #1976d2;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 6px 14px;
      margin-top: 10px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s ease;
    }

    .view-more-btn:hover {
      background: #1565c0;
      transform: translateY(-2px);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .panel-actions {
      margin-top: 15px;
      text-align: center;
    }

    .transition-overlay {
      pointer-events: all;
    }

    @media (max-width: 768px) {
      .view-more-btn {
        padding: 5px 12px;
        font-size: 0.8em;
      }
    }
  </style>
</head>

<body>
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <div>加载中...</div>
  </div>
  <div id="container"></div>
  <button class="reset-btn" onclick="resetView()">重置视角</button>
  <a href="https://www.yuque.com/jtostring/qiwsg9/wi0x1wqmn9qagvpq?singleDoc#030f4600" target="_blank">
    <button class="article-btn">技术小馆热门文章</button>
  </a>
  <div class="tooltip" id="tooltip"></div>
  <div class="touch-instructions" id="touch-instructions">单指拖动旋转 · 双指缩放</div>

  <!-- 使用降级版本的three.js，确保OrbitControls路径正确 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/controls/OrbitControls.js"></script>

  <!-- 添加性能监控工具 -->
  <script>
    // 性能监控函数
    class PerformanceMonitor {
      constructor() {
        this.isMonitoring = true;
        this.fpsArray = [];
        this.fpsAverage = 60;
        this.lowPerformanceThreshold = 40;
        this.lastTime = performance.now();
        this.frames = 0;
        this.timeElapsed = 0;
        this.checkInterval = 3000; // 3秒检查一次
        this.isLowPerformance = false;
        this.devicePixelRatio = window.devicePixelRatio || 1;
        this.isFirstCheck = true;

        // 设备信息
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isTablet = /iPad|tablet|Nexus 7|Kindle Fire/i.test(navigator.userAgent) || (this.isMobile && window.innerWidth >= 768);
        this.isSmallPhone = this.isMobile && window.innerWidth < 480;
        this.isHighResolution = window.devicePixelRatio > 2 || window.innerWidth > 1600;
      }

      update() {
        if (!this.isMonitoring) return;

        // 帧计数
        this.frames++;
        const currentTime = performance.now();
        this.timeElapsed += currentTime - this.lastTime;
        this.lastTime = currentTime;

        // 检查间隔
        if (this.timeElapsed >= this.checkInterval) {
          const fps = this.frames / (this.timeElapsed / 1000);
          this.fpsArray.push(fps);

          // 保留最近10次结果计算平均值
          if (this.fpsArray.length > 10) {
            this.fpsArray.shift();
          }

          this.fpsAverage = this.fpsArray.reduce((sum, value) => sum + value, 0) / this.fpsArray.length;

          // 首次检查较为宽容，因为加载阶段帧率可能波动
          const threshold = this.isFirstCheck ? this.lowPerformanceThreshold * 0.75 : this.lowPerformanceThreshold;
          this.isFirstCheck = false;

          // 检测是否低性能设备
          const wasLowPerformance = this.isLowPerformance;
          this.isLowPerformance = this.fpsAverage < threshold || this.isMobile || this.devicePixelRatio < 1;

          // 性能模式改变时做出响应
          if (this.isLowPerformance !== wasLowPerformance) {
            this.adjustForPerformance();
          }

          // 重置计数器
          this.frames = 0;
          this.timeElapsed = 0;
        }
      }

      adjustForPerformance() {
        if (this.isLowPerformance) {
          console.log("检测到性能不足，正在调整渲染质量...");

          // 降低渲染质量
          if (renderer) {
            renderer.setPixelRatio(1);
          }

          // 减少动画和效果
          if (controls) {
            controls.autoRotateSpeed = 0.2;
            controls.dampingFactor = 0.05;
          }

          // 特别针对低性能移动设备的优化
          if (this.isMobile || this.isSmallPhone) {
            // 更激进的优化
            if (renderer) {
              renderer.antialias = false;
            }

            // 关闭高级视觉效果
            document.querySelectorAll('.effects-heavy').forEach(el => {
              el.style.display = 'none';
            });
          }
        } else {
          console.log("性能良好，启用完整效果...");

          // 恢复渲染质量
          if (renderer) {
            const maxPixelRatio = this.isMobile ? 2 : 3;
            renderer.setPixelRatio(Math.min(this.devicePixelRatio, maxPixelRatio));
            renderer.antialias = !this.isMobile || this.isHighResolution;
          }

          // 恢复动画和效果
          if (controls) {
            controls.autoRotateSpeed = 0.25;
            controls.dampingFactor = 0.08;
          }

          // 恢复视觉效果
          document.querySelectorAll('.effects-heavy').forEach(el => {
            el.style.display = '';
          });
        }
      }

      stop() {
        this.isMonitoring = false;
      }

      resume() {
        this.isMonitoring = true;
        this.lastTime = performance.now();
      }
    }

    // 技术小馆分类数据
    const categories = [
      // 主分类
      { name: '技术小馆学习指南', color: '#42a5f5', size: 8, isMain: true },
      { name: '趣味学习', color: '#66bb6a', size: 8, isMain: true },
      { name: '开发者神器库', color: '#ffa726', size: 8, isMain: true },
      { name: '进阶提升类', color: '#42a5f5', size: 8, isMain: true },
      { name: '求职与实战类', color: '#66bb6a', size: 8, isMain: true },
      { name: '框架与中间件类', color: '#ffa726', size: 8, isMain: true },
      { name: '核心技术类', color: '#42a5f5', size: 8, isMain: true },
      { name: '基础知识类', color: '#66bb6a', size: 8, isMain: true },
      { name: '运维与部署类', color: '#ffa726', size: 8, isMain: true },

      // 技术小馆学习指南的子分类
      { name: '技术小馆文章更新记录', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },
      { name: '用户引导系统', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },
      { name: 'AI编程指南', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },
      { name: '在职提升指南', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },
      { name: '2025Java入门指南', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },
      { name: '求职者指南', color: '#8bd3dd', size: 5, parent: '技术小馆学习指南' },

      // 趣味学习的子分类
      { name: 'AI在线图片编辑平台', color: '#d1f0ee', size: 5, parent: '趣味学习' },
      { name: 'GitHub仓库播客', color: '#d1f0ee', size: 5, parent: '趣味学习' },
      { name: 'AI总结工具', color: '#d1f0ee', size: 5, parent: '趣味学习' },
      { name: '人工智能音乐创作平台', color: '#d1f0ee', size: 5, parent: '趣味学习' },
      { name: '一句话生成脑图', color: '#d1f0ee', size: 5, parent: '趣味学习' },


      // 开发者神器库的子分类
      { name: '开发者工具', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: 'Chrome插件', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: '系统工具集', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: '文件处理工具', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: '系统维护与清理', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: '知识管理与效率提升', color: '#f9d2c7', size: 5, parent: '开发者神器库' },
      { name: 'AI辅助工具', color: '#f9d2c7', size: 5, parent: '开发者神器库' },

      // 进阶提升类的子分类
      { name: '程序员的AI方向', color: '#8bd3dd', size: 5, parent: '进阶提升类' },
      { name: '源码分析', color: '#8bd3dd', size: 5, parent: '进阶提升类' },
      { name: '非技术方向', color: '#8bd3dd', size: 5, parent: '进阶提升类' },

      // 求职与实战类的子分类
      { name: '简历相关', color: '#d1f0ee', size: 5, parent: '求职与实战类' },
      { name: '项目公共模块', color: '#d1f0ee', size: 5, parent: '求职与实战类' },
      { name: '大厂高频面试题', color: '#d1f0ee', size: 5, parent: '求职与实战类' },
      { name: '非技术方向', color: '#d1f0ee', size: 5, parent: '求职与实战类' },

      // 框架与中间件类的子分类
      { name: 'SpringBoot', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: '分布式', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'WebService', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'Nginx', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: '工作流', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: '搜索技术', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: '安全框架', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'ORM', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'Spring', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'JPA', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'OSS', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'Zookeeper', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'MQ', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },
      { name: 'Netty', color: '#f9d2c7', size: 5, parent: '框架与中间件类' },

      // 核心技术类的子分类
      { name: '锁', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: 'JUC', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: 'MySQL', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: 'Oracle', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: 'Redis', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: '设计模式', color: '#8bd3dd', size: 5, parent: '核心技术类' },
      { name: 'JVM', color: '#8bd3dd', size: 5, parent: '核心技术类' },

      // 计算机基础知识的子分类（三级分类）
      { name: '网络基础知识', color: '#e6b5b5', size: 4, parent: '计算机基础知识' },
      { name: '计算机硬件基础', color: '#e6b5b5', size: 4, parent: '计算机基础知识' },
      { name: '操作系统', color: '#e6b5b5', size: 4, parent: '计算机基础知识' },

      // 前端/移动端相关技术的子分类（三级分类）
      { name: 'Uniapp', color: '#e6b5b5', size: 4, parent: '前端/移动端相关技术' },
      { name: 'Vue', color: '#e6b5b5', size: 4, parent: '前端/移动端相关技术' },

      // 运维与部署类的子分类
      { name: 'DevOps', color: '#f9d2c7', size: 5, parent: '运维与部署类' },
      { name: '服务器', color: '#f9d2c7', size: 5, parent: '运维与部署类' },

      // DevOps的子分类（三级分类）
      { name: 'Docker', color: '#e6b5b5', size: 4, parent: 'DevOps' },
      { name: 'Maven', color: '#e6b5b5', size: 4, parent: 'DevOps' },
      { name: 'IDEA', color: '#e6b5b5', size: 4, parent: 'DevOps' },
      { name: 'GIT', color: '#e6b5b5', size: 4, parent: 'DevOps' },
      { name: 'CICD', color: '#e6b5b5', size: 4, parent: 'DevOps' },

    ];

    // 随机生成更多连接节点
    const colors = ['#8bd3dd', '#f9d2c7', '#d1f0ee', '#e6b5b5', '#4cd4c0', '#f5a623'];
    const extraNodes = [];
    for (let i = 0; i < 15; i++) {
      extraNodes.push({
        name: '',  // 空名称，只显示节点
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 3 + Math.random() * 2
      });
    }

    const bubbles = [...categories, ...extraNodes];

    const container = document.getElementById('container');
    const tooltip = document.getElementById('tooltip');
    let camera, scene, renderer, controls, sphere, bubbleMeshes = [];

    // 初始化时通过DOMContentLoaded事件调用
    // init();
    // animate();

    function init() {
      console.log("正在初始化场景...");

      // 增强设备检测
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isTablet = /iPad|tablet|Nexus 7|Kindle Fire/i.test(navigator.userAgent) || (isMobile && window.innerWidth >= 768);
      const isSmallPhone = isMobile && window.innerWidth < 480;
      const isHighResolution = window.devicePixelRatio > 2 || window.innerWidth > 1600;

      // 检测浏览器性能
      const isLowPerformance = checkLowPerformanceBrowser();

      // 初始化性能监视器
      perfMonitor = new PerformanceMonitor();

      // 初始化场景
      scene = new THREE.Scene();

      // 根据设备调整FOV - 小屏幕手机使用更大FOV以显示更多内容
      const fov = isSmallPhone ? 50 : 45;
      camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);

      // 根据设备类型调整相机位置
      let cameraY, cameraZ;
      if (isSmallPhone) {
        cameraY = 80;
        cameraZ = 520;
      } else if (isTablet) {
        cameraY = 100;
        cameraZ = 500;
      } else if (isHighResolution) {
        cameraY = 120;
        cameraZ = 450;
      } else {
        cameraY = 100;
        cameraZ = 480;
      }

      // 调整初始视角
      camera.position.set(0, cameraY, cameraZ);

      // 初始化渲染器 - 根据设备性能调整
      renderer = new THREE.WebGLRenderer({
        antialias: !isMobile || isHighResolution, // 高分辨率设备开启抗锯齿
        alpha: true
      });
      renderer.setClearColor(0x111122, 1);
      renderer.setSize(window.innerWidth, window.innerHeight);

      // 根据设备调整像素比
      const maxPixelRatio = isLowPerformance ? 1 : (isMobile ? 2 : 3);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, maxPixelRatio));
      container.appendChild(renderer.domElement);

      // 添加光源 - 根据设备性能调整
      const ambientIntensity = isLowPerformance ? 0.6 : 0.5;
      const directionalIntensity = isLowPerformance ? 0.6 : 0.8;

      const ambient = new THREE.AmbientLight(0xffffff, ambientIntensity);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, directionalIntensity);
      dirLight.position.set(1, 1, 2);
      scene.add(dirLight);

      // 添加点光源 - 高性能设备添加
      if (!isLowPerformance) {
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(0, 0, 200);
        scene.add(pointLight);
      }

      // 创建装饰性粒子或线条
      createParticles();

      // 添加内容标识
      createOnlineCounter();

      // 创建网络图谱节点
      createBubbles(isLowPerformance, isSmallPhone, isTablet);

      // 初始化控制器
      console.log("正在初始化控制器...");
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.enablePan = false;

      // 根据设备调整缩放范围
      if (isSmallPhone) {
        controls.minDistance = 350;
        controls.maxDistance = 650;
      } else if (isTablet) {
        controls.minDistance = 380;
        controls.maxDistance = 700;
      } else if (isHighResolution) {
        controls.minDistance = 400;
        controls.maxDistance = 800;
      } else {
        controls.minDistance = 380;
        controls.maxDistance = 700;
      }

      controls.autoRotate = true;
      controls.autoRotateSpeed = isLowPerformance ? 0.2 : 0.25;
      controls.zoomSpeed = isMobile ? 0.6 : 1.0;
      controls.minPolarAngle = -Infinity;
      controls.maxPolarAngle = Infinity;
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle = Infinity;
      controls.rotateSpeed = isLowPerformance ? 0.7 : 0.75;
      controls.enableRotate = true;
      controls.noPan = true;

      // 解除其他可能限制旋转的属性
      if (controls.constraints) {
        if (controls.constraints.minPolarAngle !== undefined) controls.constraints.minPolarAngle = -Infinity;
        if (controls.constraints.maxPolarAngle !== undefined) controls.constraints.maxPolarAngle = Infinity;
      }

      // 添加自定义函数扩展OrbitControls功能，解除极角限制
      const originalUpdate = controls.update;
      controls.update = function () {
        const result = originalUpdate.apply(this, arguments);
        return result;
      };

      // 添加事件监听
      window.addEventListener('resize', onWindowResize, false);
      renderer.domElement.addEventListener('pointermove', onPointerMove);
      renderer.domElement.addEventListener('pointerdown', onPointerDown);

      // 添加移动端特定的触摸事件
      if (isMobile) {
        document.getElementById('touch-instructions').style.opacity = 1;
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
      }

      // 完成初始化后隐藏加载指示器
      hideLoading();

      console.log("场景初始化完成");

      // 初始化标签呼吸效果
      updateLabelPulse = addLabelPulseEffect();

      // 开始动画循环
      animate();
    }

    // 检测低性能浏览器
    function checkLowPerformanceBrowser() {
      // 检查设备内存和处理器核心数
      if (navigator.deviceMemory && navigator.deviceMemory < 4) {
        return true;
      }

      // 尝试检测硬件并发数
      if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
        return true;
      }

      // 检查是否为低端移动设备
      if (/Android [1-5]|iPhone OS [1-9]_|iPhone OS 10_/.test(navigator.userAgent)) {
        return true;
      }

      return false;
    }

    function createBubbles(isLowPerformance, isSmallPhone, isTablet) {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      const N = bubbles.length;

      // 根据设备类型调整星球大小和分布
      let UNIFORM_SIZE, UNIFORM_SPHERE_RADIUS;

      if (isSmallPhone) {
        UNIFORM_SIZE = 5;  // 小屏幕手机星球略小
        UNIFORM_SPHERE_RADIUS = 140;  // 小屏幕手机分布半径略小
      } else if (isTablet) {
        UNIFORM_SIZE = 6;
        UNIFORM_SPHERE_RADIUS = 150;
      } else {
        UNIFORM_SIZE = 6;  // 正常星球大小
        UNIFORM_SPHERE_RADIUS = 150;  // 正常分布半径
      }

      // 球形分布，无扁平化
      const FLATTEN_FACTOR = 1.0;

      for (let i = 0; i < N; i++) {
        // 使用斐波那契球体分布算法，让节点更均匀分布在球面上
        const phi = Math.acos(1 - 2 * (i + 0.5) / N);
        const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

        // 统一半径，确保球体整体更圆
        let r = UNIFORM_SPHERE_RADIUS;

        // 计算位置坐标 - 应用扁平化系数到Y轴
        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.cos(phi) * FLATTEN_FACTOR;
        const z = r * Math.sin(phi) * Math.sin(theta);

        // 创建气泡几何体，根据设备调整精度
        let bubbleGeo;
        const nodeSize = UNIFORM_SIZE;

        // 根据设备性能调整几何体精度
        let segments;
        if (isMobile) {
          if (isLowPerformance) {
            segments = 8;
          } else {
            segments = 16;
          }
        } else {
          segments = 32;
        }

        bubbleGeo = new THREE.SphereGeometry(nodeSize, segments, segments);

        // 保持色彩区分
        const bubbleMat = new THREE.MeshPhongMaterial({
          color: bubbles[i].color,
          shininess: 80,
          specular: 0x666666,
          transparent: true,
          opacity: 0.9
        });

        const mesh = new THREE.Mesh(bubbleGeo, bubbleMat);
        mesh.position.set(x, y, z);
        mesh.userData = { ...bubbles[i] };
        scene.add(mesh);
        bubbleMeshes.push(mesh);

        // 为主节点添加发光效果（高性能设备）
        if (bubbles[i].isMain && !isLowPerformance) {
          const glowGeo = new THREE.SphereGeometry(nodeSize * 1.25, segments, segments);
          const glowMat = new THREE.MeshBasicMaterial({
            color: bubbles[i].color,
            transparent: true,
            opacity: 0.18
          });
          const glowMesh = new THREE.Mesh(glowGeo, glowMat);
          glowMesh.position.copy(mesh.position);
          scene.add(glowMesh);
        }

        // 添加文字标签
        if (bubbles[i].name) {
          // 低性能设备只显示主节点
          if (isLowPerformance && !bubbles[i].isMain) {
            continue;
          }
          // 在小屏幕手机上，减少标签数量
          if (isSmallPhone && !bubbles[i].isMain && Math.random() > 0.6) {
            continue;
          }

          // 为节点创建标签
          createLabel(mesh, bubbles[i].name, isLowPerformance, isSmallPhone, isTablet);
        }
      }
    }

    // 修改createLabel函数，将sprite对象与mesh关联起来以便后续更新
    function createLabel(mesh, text, isLowPerformance, isSmallPhone, isTablet) {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isHighResolution = window.devicePixelRatio > 2 || window.innerWidth > 1600;

      // 根据设备类型调整标签尺寸和样式
      let fontSize, canvasWidth, canvasHeight, letterSpacing;

      if (isSmallPhone) {
        canvasWidth = 1280;
        canvasHeight = 480;
        fontSize = mesh.userData.isMain ? 44 : 30;
        letterSpacing = "0px";
      } else if (isTablet) {
        canvasWidth = 1600;
        canvasHeight = 640;
        fontSize = mesh.userData.isMain ? 48 : 36;
        letterSpacing = "1px";
      } else if (isHighResolution) {
        canvasWidth = 2560;
        canvasHeight = 896;
        fontSize = mesh.userData.isMain ? 52 : 40;
        letterSpacing = "1px";
      } else {
        canvasWidth = 2048;
        canvasHeight = 768;
        fontSize = mesh.userData.isMain ? 50 : 38;
        letterSpacing = "1px";
      }

      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);

      // 调整文本位置
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // 根据设备性能调整文本渲染质量
      if (!isLowPerformance) {
        // 优化渲染设置
        context.textRendering = "optimizeLegibility";
        context.imageSmoothingEnabled = true;
        context.imageSmoothingQuality = "high";
      }

      // 设置文本样式
      context.font = `${fontSize}px "Microsoft YaHei", "微软雅黑", "Helvetica Neue", Arial, sans-serif`;
      context.textAlign = 'center';
      context.textBaseline = 'middle';

      // 处理文字描边和阴影
      if (mesh.userData.isMain) {
        // 主节点标签有更强的视觉效果
        context.shadowColor = 'rgba(0, 0, 0, 0.8)';
        context.shadowBlur = isLowPerformance ? 6 : 10;
        context.shadowOffsetX = 2;
        context.shadowOffsetY = 2;
        context.fillStyle = '#ffffff';

        // 针对主节点应用强调效果
        if (!isLowPerformance) {
          // 绘制描边
          context.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          context.lineWidth = 6;
          context.strokeText(text, centerX, centerY);
        }
      } else {
        // 普通节点标签
        context.shadowColor = 'rgba(0, 0, 0, 0.6)';
        context.shadowBlur = isLowPerformance ? 4 : 8;
        context.shadowOffsetX = 1;
        context.shadowOffsetY = 1;
        context.fillStyle = 'rgba(255, 255, 255, 0.9)';
      }

      // 应用字间距
      if (letterSpacing !== "0px" && !isLowPerformance) {
        let x = centerX - (context.measureText(text).width / 2);
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const charWidth = context.measureText(char).width;
          context.fillText(char, x + (charWidth / 2), centerY);
          x += charWidth + parseFloat(letterSpacing);
        }
      } else {
        // 直接绘制文本
        context.fillText(text, centerX, centerY);
      }

      // 创建贴图
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      // 创建sprite材质
      const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0.9,
        depthTest: false,
        depthWrite: false
      });

      // 创建sprite
      const sprite = new THREE.Sprite(spriteMaterial);

      // 根据设备调整sprite尺寸
      let spriteScale;
      if (isSmallPhone) {
        spriteScale = mesh.userData.isMain ? 80 : 60;
      } else if (isTablet) {
        spriteScale = mesh.userData.isMain ? 90 : 70;
      } else if (isHighResolution) {
        spriteScale = mesh.userData.isMain ? 110 : 90;
      } else {
        spriteScale = mesh.userData.isMain ? 100 : 80;
      }

      sprite.scale.set(spriteScale, spriteScale * canvas.height / canvas.width, 1);

      // 保持与坐标系一致
      const labelPos = new THREE.Vector3().copy(mesh.position);
      const labelDistance = mesh.geometry.parameters.radius * 1.8;

      // 计算标签位置，略微偏移以避免直接重叠
      labelPos.normalize().multiplyScalar(labelDistance);
      sprite.position.copy(labelPos);

      // 关联到网格，便于后续位置更新
      sprite.userData.mesh = mesh;
      mesh.userData.label = sprite;

      // 添加到场景
      scene.add(sprite);

      return sprite;
    }

    // 调整标签缩放函数，使标签始终可见
    function updateLabelsScale() {
      // 遍历所有节点，更新其标签大小
      bubbleMeshes.forEach(mesh => {
        if (mesh.userData.labels && mesh.userData.labels.length > 0) {
          mesh.userData.labels.forEach(sprite => {
            // 计算节点到相机的向量与相机方向的夹角
            const dirToCamera = camera.position.clone().sub(mesh.position).normalize();
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const dot = dirToCamera.dot(cameraDirection);

            // 确保标签始终可见，即使在背面
            const normalizedDot = (dot + 1) / 2; // 转到[0,1]范围
            const power = 1.8; // 降低幂，使背面的标签更加可见

            // 计算缩放因子：面向相机时接近2.0，背向相机时保持0.5的最小值
            const scaleFactor = 0.5 + Math.pow(normalizedDot, power) * 1.5;

            // 应用缩放
            const baseScaleX = sprite.userData.baseScaleX;
            const baseScaleY = sprite.userData.baseScaleY;
            sprite.scale.set(baseScaleX * scaleFactor, baseScaleY * scaleFactor, 1);

            // 调整透明度，确保背面也可见
            // 面向相机时完全不透明，背向相机时保持最小不透明度
            const opacityFactor = 0.4 + Math.pow(normalizedDot, 1.5) * 0.6;
            sprite.material.opacity = opacityFactor;
          });
        }
      });
    }

    // 为Canvas 2D context添加roundRect方法（如果浏览器不支持）
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
        if (typeof radius === 'undefined') {
          radius = 5;
        }
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
        return this;
      };
    }

    function onWindowResize() {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isTablet = /iPad|tablet|Nexus 7|Kindle Fire/i.test(navigator.userAgent) || (isMobile && window.innerWidth >= 768);
      const isSmallPhone = isMobile && window.innerWidth < 480;
      const isHighResolution = window.devicePixelRatio > 2 || window.innerWidth > 1600;
      const isLandscape = window.innerWidth > window.innerHeight;

      // 调整相机FOV以适应不同屏幕尺寸和方向
      let fov;
      if (isSmallPhone) {
        fov = isLandscape ? 45 : 50;
      } else if (isTablet) {
        fov = isLandscape ? 43 : 45;
      } else {
        fov = 45;
      }

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.fov = fov;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

      // 调整UI元素位置
      updateUIElementsPosition();

      // 对于移动设备，在方向变化时更新控制器设置
      if (isMobile && controls) {
        // 在横屏模式下调整旋转速度和阻尼因子
        if (isLandscape) {
          controls.rotateSpeed = 0.7;
          controls.dampingFactor = 0.07;
        } else {
          controls.rotateSpeed = 0.75;
          controls.dampingFactor = 0.08;
        }
      }
    }

    // 更新UI元素位置函数
    function updateUIElementsPosition() {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isLandscape = window.innerWidth > window.innerHeight;

      // 调整按钮组位置
      const btnGroup = document.querySelector('.btn-group');
      if (btnGroup) {
        if (isMobile && isLandscape) {
          // 移动设备横屏模式
          btnGroup.style.right = '20px';
          btnGroup.style.bottom = '20px';
        } else if (isMobile) {
          // 移动设备竖屏模式
          btnGroup.style.right = '15px';
          btnGroup.style.bottom = '30px';
        } else {
          // 桌面设备
          btnGroup.style.right = '30px';
          btnGroup.style.bottom = '30px';
        }
      }

      // 调整触摸指示器位置
      const touchInstructions = document.getElementById('touch-instructions');
      if (touchInstructions && isMobile) {
        if (isLandscape) {
          touchInstructions.style.bottom = '70px';
          touchInstructions.style.right = '20px';
        } else {
          touchInstructions.style.bottom = '80px';
          touchInstructions.style.right = '15px';
        }
      }

      // 调整loading指示器位置
      const loadingIndicator = document.getElementById('loading');
      if (loadingIndicator) {
        loadingIndicator.style.top = `${window.innerHeight / 2 - 50}px`;
        loadingIndicator.style.left = `${window.innerWidth / 2 - 50}px`;
      }
    }

    // 添加设备方向变化监听器
    window.addEventListener('orientationchange', function () {
      // 短暂延迟，确保DOM完全更新
      setTimeout(function () {
        onWindowResize();

        // 检查性能，在方向变化后可能需要调整渲染参数
        if (perfMonitor) {
          perfMonitor.adjustForPerformance();
        }
      }, 300);
    }, false);

    function onPointerMove(event) {
      // 获取触摸或鼠标位置
      const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
      const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);

      const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
      );
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);

      // 检测交互
      const intersects = raycaster.intersectObjects(bubbleMeshes);

      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        if (mesh.userData && mesh.userData.name) {
          // 显示提示
          tooltip.style.display = 'block';
          tooltip.innerHTML = mesh.userData.name;
          tooltip.style.left = clientX + 'px';
          tooltip.style.top = clientY + 'px';

          // 稍微放大被悬停的节点以提供视觉反馈
          if (!mesh.userData.isHovered) {
            mesh.userData.originalScale = mesh.scale.x;
            mesh.scale.multiplyScalar(1.2);
            mesh.userData.isHovered = true;
          }
        }
      } else {
        // 隐藏提示
        tooltip.style.display = 'none';

        // 恢复所有节点的原始大小
        for (let i = 0; i < bubbleMeshes.length; i++) {
          const mesh = bubbleMeshes[i];
          if (mesh.userData && mesh.userData.isHovered) {
            mesh.scale.setScalar(mesh.userData.originalScale || 1);
            mesh.userData.isHovered = false;
          }
        }
      }
    }

    // 添加点击/触摸事件处理
    function onPointerDown(event) {
      // 完全禁用点击事件处理，星球不再响应点击
      return;
    }

    // 隐藏加载指示器函数
    function hideLoading() {
      const loading = document.getElementById('loading');
      loading.style.opacity = 0;
      loading.style.transition = 'opacity 0.5s ease';

      setTimeout(() => {
        loading.style.display = 'none';
      }, 500);

      // 显示触摸指引
      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        const touchInstructions = document.getElementById('touch-instructions');
        touchInstructions.style.opacity = 1;

        // 5秒后淡出
        setTimeout(() => {
          touchInstructions.style.opacity = 0.5;
        }, 5000);
      }
    }

    // 缓动函数，使动画更平滑
    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // 聚焦到选中的节点
    function focusOnNode(mesh) {
      // 计算新的相机位置
      const nodePosition = mesh.position.clone();
      const direction = nodePosition.clone().sub(camera.position).normalize();
      const distance = mesh.userData.isMain ? 250 : 150; // 主分类距离远一些，子分类距离近一些

      // 设置新的相机目标
      controls.target.copy(nodePosition);

      // 动画移动相机
      const startPosition = camera.position.clone();
      const endPosition = nodePosition.clone().sub(direction.multiplyScalar(distance));

      // 使用GSAP或自定义动画
      animateCamera(startPosition, endPosition, 1000); // 1000毫秒动画时间

      // 暂时禁用自动旋转，让用户专注于选中的节点
      const originalAutoRotate = controls.autoRotate;
      controls.autoRotate = false;

      // 5秒后恢复自动旋转
      setTimeout(() => {
        controls.autoRotate = originalAutoRotate;
      }, 5000);
    }

    // 相机动画
    function animateCamera(startPos, endPos, duration) {
      const startTime = Date.now();

      function updateCamera() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // 使用缓动函数使动画更平滑
        const easeProgress = easeInOutCubic(progress);

        // 插值计算当前位置
        camera.position.lerpVectors(startPos, endPos, easeProgress);

        if (progress < 1) {
          requestAnimationFrame(updateCamera);
        }
      }

      updateCamera();
    }

    function resetView() {
      if (!controls) return;

      // 根据设备类型调整重置视角
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isTablet = /iPad|tablet|Nexus 7|Kindle Fire/i.test(navigator.userAgent) || (isMobile && window.innerWidth >= 768);
      const isSmallPhone = isMobile && window.innerWidth < 480;
      const isHighResolution = window.devicePixelRatio > 2 || window.innerWidth > 1600;

      // 创建GSAP补间动画，平滑过渡到初始视角
      const duration = 1.5;

      // 根据设备类型设置目标位置
      let targetY, targetZ;

      if (isSmallPhone) {
        targetY = 80;
        targetZ = 520;
      } else if (isTablet) {
        targetY = 100;
        targetZ = 500;
      } else if (isHighResolution) {
        targetY = 120;
        targetZ = 450;
      } else {
        targetY = 100;
        targetZ = 480;
      }

      // 创建动画，平滑过渡到初始视角
      gsap.to(camera.position, {
        x: 0,
        y: targetY,
        z: targetZ,
        duration: duration,
        ease: "power2.out",
        onUpdate: function () {
          camera.lookAt(scene.position);
        }
      });

      // 重置控制器状态
      gsap.to(controls.target, {
        x: 0,
        y: 0,
        z: 0,
        duration: duration,
        ease: "power2.out",
        onComplete: function () {
          controls.update();

          // 恢复自动旋转
          setTimeout(function () {
            controls.autoRotate = true;
          }, 500);
        }
      });

      // 临时关闭控制器自动旋转，避免与GSAP动画冲突
      controls.autoRotate = false;
    }

    // 创建粒子系统作为背景
    function createParticles() {
      // 移动端减少粒子数量，提高性能
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const particleCount = isMobile ? 100 : 200;

      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        // 随机分布在更大的空间范围内
        positions[i * 3] = (Math.random() - 0.5) * 800;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 800;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 800;
      }

      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const particleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2,
        transparent: true,
        opacity: 0.4
      });

      const particleSystem = new THREE.Points(particles, particleMaterial);
      scene.add(particleSystem);

      // 创建一些连接线
      createConnections();
    }

    // 创建节点之间的连接线
    function createConnections() {
      // 创建主分类之间的连接
      const mainCategories = bubbles.filter(b => b.isMain);
      for (let i = 0; i < mainCategories.length; i++) {
        for (let j = i + 1; j < mainCategories.length; j++) {
          if (bubbleMeshes[i] && bubbleMeshes[j]) {
            createLine(bubbleMeshes[i].position, bubbleMeshes[j].position, 0x334455, 0.5);
          }
        }
      }

      // 创建主分类与其子分类之间的连接
      for (let i = 0; i < bubbles.length; i++) {
        if (bubbles[i].parent) {
          // 找到父分类的索引
          const parentIndex = bubbles.findIndex(b => b.name === bubbles[i].parent);
          if (parentIndex !== -1 && bubbleMeshes[i] && bubbleMeshes[parentIndex]) {
            createLine(bubbleMeshes[i].position, bubbleMeshes[parentIndex].position, 0x4477aa, 0.7);
          }
        }
      }

      // 创建一些随机连接，增加网络感
      const namedNodes = bubbles.filter(b => b.name && !b.isMain);
      for (let i = 0; i < namedNodes.length; i++) {
        const nodeIndex = bubbles.indexOf(namedNodes[i]);
        // 每个节点连接到1-2个其他节点
        const connectionCount = 1 + Math.floor(Math.random() * 2);

        for (let j = 0; j < connectionCount; j++) {
          // 随机选择另一个节点
          const targetIndex = bubbles.indexOf(namedNodes[Math.floor(Math.random() * namedNodes.length)]);
          if (targetIndex !== nodeIndex && bubbleMeshes[nodeIndex] && bubbleMeshes[targetIndex]) {
            createLine(bubbleMeshes[nodeIndex].position, bubbleMeshes[targetIndex].position, 0x223344, 0.2);
          }
        }
      }
    }

    // 创建连接线
    function createLine(pointA, pointB, color = 0x334455, opacity = 0.3) {
      const lineGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array([pointA.x, pointA.y, pointA.z, pointB.x, pointB.y, pointB.z]);
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const lineMaterial = new THREE.LineBasicMaterial({
        color: color,
        transparent: true,
        opacity: opacity
      });

      const line = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(line);
      return line;
    }

    // 创建在线人数显示
    function createOnlineCounter() {
      // 使用HTML元素显示在线人数
      const counterDiv = document.createElement('div');
      counterDiv.style.position = 'fixed';
      counterDiv.style.bottom = '30px';
      counterDiv.style.width = '100%';
      counterDiv.style.textAlign = 'center';
      counterDiv.style.color = '#ffffff';
      counterDiv.style.fontSize = '1.5em';
      counterDiv.style.fontWeight = 'bold';
      counterDiv.style.zIndex = '100';
      counterDiv.innerHTML = '技术小馆内容预览图';
      document.body.appendChild(counterDiv);

      // 创建分类信息面板
      const infoPanel = document.createElement('div');
      infoPanel.id = 'category-info';
      infoPanel.style.position = 'fixed';
      infoPanel.style.left = '30px';
      infoPanel.style.top = '30px';
      infoPanel.style.background = 'rgba(30,30,60,0.85)';
      infoPanel.style.color = '#fff';
      infoPanel.style.padding = '20px';
      infoPanel.style.borderRadius = '10px';
      infoPanel.style.maxWidth = '300px';
      infoPanel.style.zIndex = '100';
      infoPanel.style.display = 'none';
      infoPanel.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
      infoPanel.style.transition = 'all 0.3s ease';
      document.body.appendChild(infoPanel);

      // 移动端调整底部提示
      if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        counterDiv.style.fontSize = '1.1em';
        counterDiv.style.bottom = '50px';
      }
    }

    // 显示分类信息
    function showCategoryInfo(categoryName) {
      const infoPanel = document.getElementById('category-info');
      let content = '';

      // 根据分类名称显示对应的子分类
      switch (categoryName) {
        case '进阶提升类':
          content = `
        <h3>进阶提升类</h3>
        <ul>
          <li>程序员的AI方向【前沿技术】</li>
          <li>源码分析【深度学习】</li>
          <li>非技术方向【软实力提升】</li>
        </ul>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
          break;
        case '求职与实战类':
          content = `
        <h3>求职与实战类</h3>
        <ul>
          <li>简历相关</li>
          <li>项目公共模块【项目构建】</li>
          <li>实战项目【经验积累】</li>
          <li>大厂高频面试题【求职准备】</li>
        </ul>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
          break;
        case '框架与中间件类':
          content = `
        <h3>框架与中间件类</h3>
        <ul>
          <li>SpringBoot【主流框架】</li>
          <li>微服务【架构设计】</li>
          <li>分布式【系统架构】</li>
          <li>WebService【网络通信】</li>
          <li>Nginx【Web服务器】</li>
          <li>更多中间件...</li>
        </ul>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
          break;
        case '程序员的AI方向':
          content = `
        <h3>程序员的AI方向</h3>
        <ul>
          <li>Cursor教程</li>
          <li>实用的Prompt</li>
          <li>AI基础理论</li>
          <li>Java与AI</li>
          <li>AI应用</li>
          <li>前沿AI框架与效能工具</li>
          <li>Deepseek</li>
        </ul>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
          break;
        case '源码分析':
          content = `
        <h3>源码分析</h3>
        <ul>
          <li>Guava</li>
          <li>Netty</li>
          <li>消息队列</li>
          <li>并发与多线程</li>
          <li>Java集合</li>
          <li>MyBatis</li>
          <li>Spring</li>
          <li>SpringBoot</li>
        </ul>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
          break;
        default:
          content = `
        <h3>${categoryName}</h3>
        <p>点击查看详细内容</p>
        <div class="panel-actions">
          <button class="view-more-btn" onclick="transitionToContent('${categoryName}')">查看详情</button>
        </div>
      `;
      }

      infoPanel.innerHTML = content;
      infoPanel.style.display = 'block';

      // 添加关闭按钮
      const closeBtn = document.createElement('div');
      closeBtn.innerHTML = '×';
      closeBtn.style.position = 'absolute';
      closeBtn.style.right = '10px';
      closeBtn.style.top = '10px';
      closeBtn.style.cursor = 'pointer';
      closeBtn.style.fontSize = '20px';
      closeBtn.style.fontWeight = 'bold';
      closeBtn.onclick = () => {
        infoPanel.style.display = 'none';
      };
      infoPanel.appendChild(closeBtn);
    }

    // 添加双指触摸支持
    let touchStartDistance = 0;
    let touchStartScale = 1;
    let isMultiTouch = false;

    function handleTouchStart(event) {
      if (event.touches.length >= 2) {
        isMultiTouch = true;

        // 计算两指之间的距离
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);

        // 记录当前缩放级别
        touchStartScale = camera.position.distanceTo(controls.target);

        // 禁用OrbitControls，避免冲突
        controls.enabled = false;

        // 防止页面滚动
        event.preventDefault();
        document.body.style.overflow = 'hidden';
      } else {
        isMultiTouch = false;
        controls.enabled = true;
        document.body.style.overflow = 'hidden';
      }

      // 隐藏触摸提示
      const touchInstructions = document.getElementById('touch-instructions');
      if (touchInstructions) {
        touchInstructions.style.opacity = '0';
      }
    }

    function handleTouchMove(event) {
      if (isMultiTouch && event.touches.length >= 2) {
        // 计算当前两指距离
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        const touchDistance = Math.sqrt(dx * dx + dy * dy);

        // 计算缩放比例
        const scale = touchStartDistance / touchDistance;

        // 设置新的相机位置
        const newDistance = touchStartScale * scale;

        // 确保缩放在最小和最大范围内
        if (newDistance >= controls.minDistance && newDistance <= controls.maxDistance) {
          const dir = camera.position.clone().sub(controls.target).normalize();
          camera.position.copy(controls.target.clone().add(dir.multiplyScalar(newDistance)));

          // 确保更新控制器以应用新位置
          controls.update();
        }

        // 防止页面滚动
        event.preventDefault();
      } else if (event.touches.length === 1) {
        // 单指拖动时防止页面滚动
        event.preventDefault();
      }
    }

    function handleTouchEnd(event) {
      if (event.touches.length < 2) {
        isMultiTouch = false;
        controls.enabled = true;

        // 恢复页面滚动
        setTimeout(() => {
          document.body.style.overflow = '';
        }, 100);
      }
    }

    // 修改为使用帧计数器而不是随机函数来控制移动端渲染频率
    let frameCount = 0;
    let perfMonitor;

    function animate() {
      requestAnimationFrame(animate);

      // 性能优化 - 移动端降低更新频率，但保持连续性
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      frameCount++;

      // 更新性能监视器 (如果存在)
      if (perfMonitor) perfMonitor.update();

      // 确保控制器可以无限旋转
      if (controls) {
        // 始终确保无限旋转功能
        controls.minPolarAngle = -Infinity;
        controls.maxPolarAngle = Infinity;
        controls.minAzimuthAngle = -Infinity;
        controls.maxAzimuthAngle = Infinity;
      }

      // 根据设备性能自适应渲染
      if (!isMobile || frameCount % 2 === 0) { // 移动端每两帧渲染一次
        // 确保控制器更新，这样就能正确处理旋转
        controls.update();

        // 为主节点添加呼吸灯/脉冲效果
        bubbleMeshes.forEach(mesh => {
          if (mesh.userData.isMain) {
            const scale = 1 + 0.08 * Math.sin(Date.now() * 0.003);
            mesh.scale.set(scale, scale, scale);
          }
        });

        // 更新标签大小，使其根据视角调整
        updateLabelsScale();

        // 更新标签呼吸效果
        if (updateLabelPulse) {
          updateLabelPulse();
        }

        // 渲染场景
        renderer.render(scene, camera);
      }
    }

    // 增加一个函数用于设置自动旋转状态
    function toggleAutoRotate(enable) {
      if (controls) {
        controls.autoRotate = enable;
      }
    }

    // 初始化时创建性能监视器
    window.addEventListener('DOMContentLoaded', () => {
      // 初始化场景
      init();

      // 添加转场效果样式
      addTransitionStyles();

      // 给一点额外的时间加载资源
      setTimeout(() => {
        if (document.getElementById('loading')) {
          hideLoading();
        }
      }, 1000);
    });

    // 添加页面卸载事件处理，防止内存泄漏
    function cleanUp() {
      // 删除事件监听器
      window.removeEventListener('resize', onWindowResize);
      renderer.domElement.removeEventListener('pointermove', onPointerMove);
      renderer.domElement.removeEventListener('pointerdown', onPointerDown);

      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (isMobile) {
        document.removeEventListener('touchstart', handleTouchStart);
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
      }

      // 释放THREE.js资源
      renderer.dispose();

      // 释放几何体和材质
      for (let i = 0; i < bubbleMeshes.length; i++) {
        bubbleMeshes[i].geometry.dispose();
        bubbleMeshes[i].material.dispose();
      }

      // 释放场景中的所有对象
      function disposeNode(node) {
        if (node.geometry) node.geometry.dispose();
        if (node.material) {
          if (Array.isArray(node.material)) {
            node.material.forEach(material => material.dispose());
          } else {
            node.material.dispose();
          }
        }
      }

      scene.traverse(disposeNode);

      scene = null;
      camera = null;
      controls = null;
      bubbleMeshes = [];
    }

    // 监听页面卸载
    window.addEventListener('beforeunload', cleanUp);

    // 移动设备上，当页面进入后台时，暂停渲染以节省资源
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // 页面不可见时，暂停动画
        controls.autoRotate = false;
      } else {
        // 页面可见时，恢复动画
        controls.autoRotate = true;
      }
    });

    // 添加新函数：转场动画效果
    function transitionToContent(category) {
      // 创建遮罩层
      const overlay = document.createElement('div');
      overlay.className = 'transition-overlay';
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.backgroundColor = 'rgba(0,0,0,0)';
      overlay.style.zIndex = '1000';
      overlay.style.transition = 'background-color 0.7s ease';
      document.body.appendChild(overlay);

      // 隐藏控制按钮和信息面板
      document.getElementById('category-info').style.display = 'none';
      document.querySelector('.reset-btn').style.opacity = '0';
      document.querySelector('.article-btn').style.opacity = '0';

      // 执行相机放大动画
      const selectedCategory = bubbles.find(b => b.name === category);
      let targetMesh;

      if (selectedCategory) {
        // 找到对应节点
        targetMesh = bubbleMeshes.find(mesh => mesh.userData.name === category);
      }

      if (targetMesh) {
        // 设置放大动画
        const zoomDuration = 1200; // 毫秒

        // 记录原始状态
        const startPosition = camera.position.clone();
        const startTarget = controls.target.clone();

        // 计算目标位置 (更靠近星球)
        const dirToTarget = targetMesh.position.clone().normalize();
        const endPosition = targetMesh.position.clone().sub(dirToTarget.multiplyScalar(20));

        // 放大动画
        let startTime = null;

        function zoomAnimation(currentTime) {
          if (!startTime) startTime = currentTime;
          const elapsed = currentTime - startTime;
          const progress = Math.min(elapsed / zoomDuration, 1);

          // 使用缓动函数
          const easeProgress = easeInOutCubic(progress);

          // 相机向目标靠近
          camera.position.lerpVectors(startPosition, endPosition, easeProgress);
          controls.target.lerpVectors(startTarget, targetMesh.position, easeProgress);

          // 目标星球放大
          if (targetMesh) {
            targetMesh.scale.set(1 + easeProgress * 2, 1 + easeProgress * 2, 1 + easeProgress * 2);
          }

          // 淡入遮罩
          overlay.style.backgroundColor = `rgba(0,0,0,${easeProgress * 0.9})`;

          if (progress < 1) {
            requestAnimationFrame(zoomAnimation);
          } else {
            // 动画结束，跳转或显示内容
            setTimeout(() => {
              // 这里可以替换为实际跳转链接
              const urls = {
                '进阶提升类': 'https://www.yuque.com/jtostring/qiwsg9/az1h97',
                '求职与实战类': 'https://www.yuque.com/jtostring/qiwsg9/aqeaul',
                '框架与中间件类': 'https://www.yuque.com/jtostring/qiwsg9/cxsedl',
                '程序员的AI方向': 'https://www.yuque.com/jtostring/qiwsg9/nzf74evugko8r23h',
                '源码分析': 'https://www.yuque.com/jtostring/qiwsg9/rgoyp2',
                // 可以添加更多分类的URL
                'default': 'https://www.yuque.com/jtostring/qiwsg9'
              };

              // 获取URL
              const targetUrl = urls[category] || urls['default'];

              // 跳转页面
              window.location.href = targetUrl;
            }, 500);
          }
        }

        requestAnimationFrame(zoomAnimation);
      } else {
        // 如果没有找到节点，直接淡出
        overlay.style.backgroundColor = 'rgba(0,0,0,0.9)';

        setTimeout(() => {
          // 默认跳转
          window.location.href = 'https://www.yuque.com/jtostring/qiwsg9';
        }, 800);
      }
    }

    // 添加必要的CSS样式
    function addTransitionStyles() {
      const styleSheet = document.createElement('style');
      styleSheet.textContent = `
        .view-more-btn {
          background: #1976d2;
          color: white;
          border: none;
          border-radius: 20px;
          padding: 6px 14px;
          margin-top: 10px;
          cursor: pointer;
          font-size: 0.9em;
          transition: all 0.2s ease;
        }
        
        .view-more-btn:hover {
          background: #1565c0;
          transform: translateY(-2px);
          box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .panel-actions {
          margin-top: 15px;
          text-align: center;
        }
        
        .transition-overlay {
          pointer-events: all;
        }
        
        @media (max-width: 768px) {
          .view-more-btn {
            padding: 5px 12px;
            font-size: 0.8em;
          }
        }
      `;
      document.head.appendChild(styleSheet);
    }

    // 增加一个函数，给标签添加轻微的呼吸动画效果
    function addLabelPulseEffect() {
      // 为每个文字标签添加轻微呼吸效果
      const labelPulses = [];

      bubbleMeshes.forEach(mesh => {
        if (mesh.userData.labels && mesh.userData.labels.length > 0) {
          mesh.userData.labels.forEach(sprite => {
            // 为每个标签创建一个随机的脉冲频率
            labelPulses.push({
              sprite: sprite,
              frequency: 0.0005 + Math.random() * 0.001,
              phase: Math.random() * Math.PI * 2
            });
          });
        }
      });

      // 在动画循环中应用呼吸效果
      return function updatePulse() {
        const time = Date.now();

        labelPulses.forEach(pulse => {
          // 只对面向相机的标签应用脉冲效果（避免计算浪费）
          if (pulse.sprite.material.opacity > 0.5) {
            // 生成一个轻微的缩放波动，范围是[0.98, 1.02]
            const scale = 1 + 0.02 * Math.sin(time * pulse.frequency + pulse.phase);

            // 应用到当前比例
            pulse.sprite.scale.x *= scale;
            pulse.sprite.scale.y *= scale;
          }
        });
      };
    }

    // 添加一个全局变量存储更新函数
    let updateLabelPulse;
  </script>
</body>

</html>
